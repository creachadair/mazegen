/*
  Name:     maze.h
  Purpose:  Maze generation library.
  Author:   M. J. Fromberger <http://github.com/creachadair>

  Copyright (C) 1998-2006 M. J. Fromberger, All Rights Reserved.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.
 */

#ifndef MAZE_H_
#define MAZE_H_

#include <stdio.h>

/** Directional constants for navigating and constructing a maze grid. */
enum { DIR_U = 0, DIR_R = 1, DIR_D = 2, DIR_L = 3 };

/** A compact representation of a single "node" in a maze graph.  In
    this library, a maze is basically a rectilinear planar graph, in
    which vertices represent positions in space and edges represent
    direct reachability.
 */
typedef struct {
  unsigned char r_wall : 1; /* Cell has a right wall  */
  unsigned char b_wall : 1; /* Cell has a bottom wall */
  unsigned char marker : 2; /* Marker direction       */
  unsigned char visit : 1;  /* Visitation indicator   */
} maze_node;

/** Represents a single row or column index. */
typedef unsigned int rowcol_t;

/** A maze. */
typedef struct {
  maze_node *cells;
  rowcol_t *sets;
  rowcol_t n_rows;
  rowcol_t n_cols;
  rowcol_t exit_1; /* Bottom 2 bits indicate direction */
  rowcol_t exit_2;
} maze_t;

/** A random number generator, uniform distribution over 0,..1 */
typedef double (*rand_f)(void);

/* Some macros to simplify access to maze_t fields through a pointer. */
#define OFFSET(M, R, C) (((M)->n_cols * (R)) + (C))
#define CELLP(M, R, C) ((M)->cells + OFFSET(M, R, C))
#define CELLV(M, R, C) (*CELLP(M, R, C))
#define EXIT(P, DIR) (((P) << 2) + (DIR))
#define EPOS(EXIT) ((EXIT) >> 2)
#define EDIR(EXIT) ((EXIT)&0x3)

/** Initialize a new empty maze structure.

    @param nr    The number of rows the maze should have.
    @param nc    The number of columns the maze should have.
 */
int maze_init(maze_t *mp, rowcol_t nr, rowcol_t nc);

/** Load a maze description from a file.  The format of the input
    file is the same as is generated by maze_store().  Initializes
    the maze_t structure as a side-effect.

    @param mp    Pointer to an uninitialized maze structure.
    @param ifp   Input stream to read data from.
 */
int maze_load(maze_t *mp, FILE *ifp);

/** Store a pickled representation of a maze into a file.  The format
    of the output is opaque.

    @param mp    Pointer to an initialized maze structure.
    @param ofp   Output stream to write data to.
 */
void maze_store(maze_t *mp, FILE *ofp);

/** Release the storage used by an existing maze structure. */
void maze_clear(maze_t *mp);

/** Restore an existing maze structure to a pristine state; all graph
    edges are deleted, leaving a grid of vertices with no neighbors.
 */
void maze_reset(maze_t *mp);

/** Remove marks left by pathfinding and other traversal algorithms. */
void maze_unmark(maze_t *mp);

/** Generate a maze at random.

    @param mp     Pointer to an initialized maze structure.
    @param random A random generator function (see rand_f).
 */
int maze_generate(maze_t *mp, rand_f random);

/** Find a path between two vertices in a maze.  The path is recorded
    by marking the vertices of the maze.  Row and column indices are
    zero indexed.

    Note that there is currently no way to tell whether or not path
    finding succeeded, except to try traversing the path.

    @param mp         Pointer to an initialized maze structure.
    @param start_row  Row number of starting vertex.
    @param start_col  Column number of starting vertex.
    @param end_row    Row number of ending vertex.
    @param end_col    Column number of ending vertex.
 */
void maze_find_path(maze_t *mp, rowcol_t start_row, rowcol_t start_col,
                    rowcol_t end_row, rowcol_t end_col);

/** Write a maze in PNG format to the specified output file.

    @param mp         Pointer to an initialized maze structure.
    @param ofp        Output stream to write the PNG to.
    @param h_res      Width of generated image, in pixels.
    @param v_res      Height of generated image, in pixels.
 */
void maze_write_png(maze_t *mp, FILE *ofp, unsigned int h_res,
                    unsigned int v_res);

/** Write a maze in Encapsulated PostScript (EPS) format.

    @param mp         Pointer to an initialized maze structure.
    @param ofp        Output stream to write the EPS to.
    @param h_res      Width of generated image, in points.
    @param v_res      Height of generated image, in points.
 */
void maze_write_eps(maze_t *mp, FILE *ofp, unsigned int h_res,
                    unsigned int v_res);

/** Write a maze in ASCII text format.

    @param mp         Pointer to an initialized maze structure.
    @param ofp        Output stream to write the text to.
    @param h_res      Ignored in this function (width).
    @param v_res      Ignored in this function (height).
 */
void maze_write_text(maze_t *mp, FILE *ofp, unsigned int h_res,
                     unsigned int v_res);

#endif /* end MAZE_H_ */
